<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.teamcity/lib/Forest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.teamcity/lib/Forest.kt" />
              <option name="originalContent" value="package lib&#10;&#10;import jetbrains.buildServer.configs.kotlin.*&#10;import jetbrains.buildServer.configs.kotlin.BuildTypeSettings&#10;import jetbrains.buildServer.configs.kotlin.triggers.vcs&#10;import jetbrains.buildServer.configs.kotlin.triggers.schedule&#10;&#10;/**&#10; * 用“路径清单 + 规则”生成整片森林。&#10; * - branches：分支列表（每个分支一棵树）&#10; * - leafPaths：所有叶子路径&#10; * - rules：路径到模板的匹配规则&#10; * - defaultTpl：未命中规则时的兜底模板&#10; * - vcsRoot：统一的 VCS root&#10; */&#10;fun buildForestFromPaths(&#10;    root: Project,&#10;    idp: String,&#10;    branches: List&lt;String&gt;,&#10;    leafPaths: List&lt;String&gt;,&#10;    rules: List&lt;TemplateRule&gt;,&#10;    defaultTpl: Template,&#10;    vcsRoot: VcsRoot&#10;) {&#10;    val roots = buildTreeFromPaths(leafPaths)&#10;&#10;    branches.forEach { branch -&gt;&#10;        val prjBranch = Project {&#10;            id(&quot;${idp}_Prj_$branch&quot;)&#10;            name = branch&#10;            params { param(&quot;BRANCH&quot;, branch) }&#10;        }&#10;        root.subProject(prjBranch)&#10;&#10;        val composite = BuildType {&#10;            id(&quot;${idp}_BT_${branch}_Composite&quot;)&#10;            name = &quot;00_ ENTRANCE (Composite)&quot;&#10;            type = BuildTypeSettings.Type.COMPOSITE&#10;            vcs {&#10;                root(vcsRoot)&#10;                branchFilter = &quot;+:%BRANCH%&quot;&#10;            }&#10;            triggers {&#10;                vcs {&#10;                    branchFilter = &quot;+:%BRANCH%&quot;&#10;                    watchChangesInDependencies = true&#10;                }&#10;            }&#10;            // 夜间定时（示例：03:00；如不需要可删除）&#10;            triggers {&#10;                schedule {&#10;                    schedulingPolicy = daily { hour = 3; minute = 0 }&#10;                    branchFilter = &quot;+:%BRANCH%&quot;&#10;                    withPendingChangesOnly = false&#10;                    enforceCleanCheckout = true&#10;                    buildParams {&#10;                        param(&quot;RUN_MODE&quot;, &quot;nightly&quot;)&#10;                        param(&quot;CLEAN_BUILD&quot;, &quot;true&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        prjBranch.buildType(composite)&#10;&#10;        val dispatcher = BuildType {&#10;            id(&quot;${idp}_BT_${branch}_Dispatcher&quot;)&#10;            name = &quot;01_ DISPATCHER&quot;&#10;            templates(defaultTpl)&#10;        }&#10;        prjBranch.buildType(dispatcher)&#10;&#10;        data class Built(val allLeaves: List&lt;BuildType&gt;, val fin: BuildType)&#10;&#10;        fun buildGroup(parent: Project, pathIds: List&lt;String&gt;, node: Node): Built {&#10;            val groupPathId = (pathIds + node.id).joinToString(&quot;_&quot;)&#10;            val prj = Project { id(&quot;${idp}_Prj_${branch}_$groupPathId&quot;); name = node.name }&#10;            parent.subProject(prj)&#10;&#10;            val leaves = node.leaves.map { leafKey -&gt;&#10;                BuildType().also { bt -&gt;&#10;                    bt.id(&quot;${idp}_BT_${branch}_${groupPathId}_${safeId(leafKey)}&quot;)&#10;                    bt.name = &quot;${branch}_${groupPathId}_$leafKey&quot;&#10;                    bt.templates(pickTpl(groupPathId, leafKey, rules, defaultTpl))&#10;                    bt.params {&#10;                        param(&quot;GROUP_PATH&quot;, groupPathId)&#10;                        param(&quot;LEAF_KEY&quot;,   leafKey)&#10;                    }&#10;                    bt.dependencies {&#10;                        snapshot(dispatcher) { synchronizeRevisions = true }&#10;                    }&#10;                    prj.buildType(bt)&#10;                }&#10;            }&#10;&#10;            val kids = node.children.values.map { child -&gt;&#10;                buildGroup(prj, pathIds + node.id, child)&#10;            }&#10;&#10;            val fin = BuildType {&#10;                id(&quot;${idp}_BT_${branch}_${groupPathId}_finalize&quot;)&#10;                name = &quot;99_ ${groupPathId}_finalize&quot;&#10;                templates(pickTpl(groupPathId, null, rules, defaultTpl))&#10;                dependencies {&#10;                    leaves.forEach { ch -&gt;&#10;                        snapshot(ch) { synchronizeRevisions = true; onDependencyFailure = FailureAction.ADD_PROBLEM }&#10;                        artifacts(ch) { artifactRules = &quot;** =&gt; inputs/${ch.name}/&quot; }&#10;                    }&#10;                    kids.forEach { b -&gt;&#10;                        snapshot(b.fin) { synchronizeRevisions = true; onDependencyFailure = FailureAction.ADD_PROBLEM }&#10;                        artifacts(b.fin) { artifactRules = &quot;** =&gt; inputs/${b.fin.name}/&quot; }&#10;                    }&#10;                }&#10;            }&#10;            prj.buildType(fin)&#10;            return Built(leaves + kids.flatMap { it.allLeaves }, fin)&#10;        }&#10;&#10;        val builtRoots = roots.values.map { buildGroup(prjBranch, emptyList(), it) }&#10;&#10;        composite.dependencies {&#10;            snapshot(dispatcher) { synchronizeRevisions = true }&#10;            builtRoots.forEach { b -&gt;&#10;                b.allLeaves.forEach { snapshot(it) { synchronizeRevisions = true } }&#10;                snapshot(b.fin) { synchronizeRevisions = true }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package lib&#10;&#10;import jetbrains.buildServer.configs.kotlin.*&#10;import jetbrains.buildServer.configs.kotlin.BuildTypeSettings&#10;import jetbrains.buildServer.configs.kotlin.triggers.vcs&#10;import jetbrains.buildServer.configs.kotlin.triggers.schedule&#10;&#10;/**&#10; * 用“路径清单 + 规则”生成整片森林。&#10; * - branches：分支列表（每个分支一棵树）&#10; * - leafPaths：所有叶子路径&#10; * - rules：路径到模板的匹配规则&#10; * - defaultTpl：未命中规则时的兜底模板&#10; * - vcsRoot：统一的 VCS root&#10; */&#10;fun buildForestFromPaths(&#10;    root: Project,&#10;    idp: String,&#10;    branches: List&lt;String&gt;,&#10;    leafPaths: List&lt;String&gt;,&#10;    rules: List&lt;TemplateRule&gt;,&#10;    defaultTpl: Template,&#10;    vcsRoot: VcsRoot&#10;) {&#10;    val roots = buildTreeFromPaths(leafPaths)&#10;&#10;    branches.forEach { branch -&gt;&#10;        val prjBranch = Project {&#10;            id(&quot;${idp}_Prj_$branch&quot;)&#10;            name = branch&#10;            params { param(&quot;BRANCH&quot;, branch) }&#10;        }&#10;        root.subProject(prjBranch)&#10;&#10;        val composite = BuildType {&#10;            id(&quot;${idp}_BT_${branch}_Composite&quot;)&#10;            name = &quot;00_ ENTRANCE (Composite)&quot;&#10;            type = BuildTypeSettings.Type.COMPOSITE&#10;            vcs {&#10;                root(vcsRoot)&#10;                branchFilter = &quot;+:%BRANCH%&quot;&#10;            }&#10;            triggers {&#10;                vcs {&#10;                    branchFilter = &quot;+:%BRANCH%&quot;&#10;                    watchChangesInDependencies = true&#10;                }&#10;            }&#10;            // 夜间定时（示例：03:00；如不需要可删除）&#10;            triggers {&#10;                schedule {&#10;                    schedulingPolicy = daily { hour = 3; minute = 0 }&#10;                    branchFilter = &quot;+:%BRANCH%&quot;&#10;                    withPendingChangesOnly = false&#10;                    enforceCleanCheckout = true&#10;                    buildParams {&#10;                        param(&quot;RUN_MODE&quot;, &quot;nightly&quot;)&#10;                        param(&quot;CLEAN_BUILD&quot;, &quot;true&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        prjBranch.buildType(composite)&#10;&#10;        val dispatcher = BuildType {&#10;            id(&quot;${idp}_BT_${branch}_Dispatcher&quot;)&#10;            name = &quot;01_ DISPATCHER&quot;&#10;            templates(defaultTpl)&#10;        }&#10;        prjBranch.buildType(dispatcher)&#10;&#10;        data class Built(val allLeaves: List&lt;BuildType&gt;, val fin: BuildType)&#10;&#10;        fun buildGroup(parent: Project, pathIds: List&lt;String&gt;, node: Node): Built {&#10;            val groupPathId = (pathIds + node.id).joinToString(&quot;_&quot;)&#10;            val prj = Project { id(&quot;${idp}_Prj_${branch}_$groupPathId&quot;); name = node.name }&#10;            parent.subProject(prj)&#10;&#10;            val leaves = node.leaves.map { leafKey -&gt;&#10;                BuildType().also { bt -&gt;&#10;                    bt.id(&quot;${idp}_BT_${branch}_${groupPathId}_${safeId(leafKey)}&quot;)&#10;                    bt.name = &quot;${branch}_${groupPathId}_$leafKey&quot;&#10;                    bt.templates(pickTpl(groupPathId, leafKey, rules, defaultTpl))&#10;                    bt.params {&#10;                        param(&quot;GROUP_PATH&quot;, groupPathId)&#10;                        param(&quot;LEAF_KEY&quot;,   leafKey)&#10;                    }&#10;                    bt.dependencies {&#10;                        snapshot(dispatcher) { synchronizeRevisions = true }&#10;                    }&#10;                    prj.buildType(bt)&#10;                }&#10;            }&#10;&#10;            val kids = node.children.values.map { child -&gt;&#10;                buildGroup(prj, pathIds + node.id, child)&#10;            }&#10;&#10;            val fin = BuildType {&#10;                id(&quot;${idp}_BT_${branch}_${groupPathId}_finalize&quot;)&#10;                name = &quot;99_ ${groupPathId}_finalize&quot;&#10;                templates(pickTpl(groupPathId, null, rules, defaultTpl))&#10;                dependencies {&#10;                    leaves.forEach { ch -&gt;&#10;                        snapshot(ch) { synchronizeRevisions = true; onDependencyFailure = FailureAction.ADD_PROBLEM }&#10;                        artifacts(ch) { artifactRules = &quot;** =&gt; inputs/${ch.name}/&quot; }&#10;                    }&#10;                    kids.forEach { b -&gt;&#10;                        snapshot(b.fin) { synchronizeRevisions = true; onDependencyFailure = FailureAction.ADD_PROBLEM }&#10;                        artifacts(b.fin) { artifactRules = &quot;** =&gt; inputs/${b.fin.name}/&quot; }&#10;                    }&#10;                }&#10;            }&#10;            prj.buildType(fin)&#10;            return Built(leaves + kids.flatMap { it.allLeaves }, fin)&#10;        }&#10;&#10;        val builtRoots = roots.values.map { buildGroup(prjBranch, emptyList(), it) }&#10;&#10;        composite.dependencies {&#10;            snapshot(dispatcher) { synchronizeRevisions = true }&#10;            builtRoots.forEach { b -&gt;&#10;                b.allLeaves.forEach { snapshot(it) { synchronizeRevisions = true } }&#10;                snapshot(b.fin) { synchronizeRevisions = true }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>